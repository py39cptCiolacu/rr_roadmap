## Table of Contents

1. [Motivation](#1-motivation)
2. [Architecture](#2-architecture)
3. [How development will work](#3-how-development-will-work)
4. [Beta version 0.1](#4-beta-version-01)
5. [Sandbox](#5-sandbox)
6. [Want to help?](#6-want-to-help)

---

### 1. Motivation

This project is an experimental interpreter whose primary goal is to explore, at the interpreter level, a tighter and more explicit bridge between R and Python.

In practice, many real-world data pipelines rely on a **mixed R–Python stack**, combining R’s strengths in statistics and data analysis with Python’s rich ecosystem for machine learning, infrastructure, and tooling. Today, the integration is usually handled at the library or application level through ad-hoc bindings or foreign function interfaces.

This interpreter investigates a different approach: enabling **direct native Python execution from within an R-like runtime**, with well-defined semantics, explicit synchronization, and a clear execution model.

The focus is **not production readiness**, but experimentation, learning, and evaluating architectural trade-offs at the interpreter and runtime level.

---

### 2. Architecture

The interpreter is **bytecode-based**, using an instruction set conceptually similar to CPython. Function calls follow a **lazy evaluation model**, a core feature of R.

The primary goal of this experimental interpreter is to enable direct calls to native Python code from within the interpreter itself. This is achieved by integrating the Python C API into RR through a post-processing step that modifies the C code generated after the RPython build phase (as described in section 3).
At the bytecode level, this mechanism is implemented using three specialized opcodes:

- **ENTRY_SYNC**: Determines variables required by Python code, forces lazy values, pushes them to the stack.
- **PYTHON_CALL**: Executes Python code via the Python C API. Marks execution boundary between RR and Python runtime.
- **EXIT_SYNC**: Synchronizes variables back into RR scope after Python execution.

> ⚠️ Future versions may decompose these opcodes into more granular instructions.

### Technical clarifications

From a design perspective, this architecture introduces a controlled synchronization boundary between the RR runtime and the Python runtime. Rather than tightly coupling the two execution models, the interpreter explicitly defines:

- when data enters the Python runtime (ENTRY_SYNC)
- when execution occurs (PYTHON_CALL)
- when state is reconciled back into RR (EXIT_SYNC)

This separation is important because:

- RR and Python follow different evaluation strategies (lazy vs. eager)
- Python objects and RR values may have different memory models and lifetimes
- Synchronization must be explicit to avoid undefined behavior or silent state corruption

By encoding this behavior directly into bytecode, the interpreter preserves a clear, inspectable, and debuggable execution model, instead of hiding cross-runtime interaction behind opaque runtime calls.

---

### 3. How development will work

The core of the interpreter is implemented using **RPython**, a restricted subset of Python designed specifically for building interpreters and virtual machines. RPython comes with a powerful toolchain that provides many features out of the box, including a parser, AST generation, garbage collection, JIT compilation, and extensive argument and type checks.
Using RPython significantly **simplifies the development process**, but it also introduces several constraints. One of the most important limitations is that all variable types must be statically inferable by the RPython toolchain. Because of these restrictions, certain components (most notably the Python Calling Module) cannot be implemented directly in RPython.

To work around this limitation, I adopted an **unconventional** and intentionally experimental approach: modifying the C code generated by the RPython toolchain.
The idea is to define a placeholder function _call_python_ inside the RPython codebase. This function performs no operation at the RPython level. After the RPython build process completes, a secondary script is executed to:

- Locate the generated C implementation of call_python
- Replace it with a custom, hand-written C implementation that uses the Python C API
- Adjust the generated Makefile as needed
- Rebuild the project to produce an updated executable
  > ⚠️ This approach is experimental and fragile, not for production use.

The diagram below illustrates this workflow in more detail.

![Development Diagram](https://i.ibb.co/bgkHTb3Z/Diagram-PNG-drawio.png)

---

### 4. Beta version 0.1

**Current features:**

- Basic data types: integer, numeric, bool, string _(string ops not yet supported)_
- Arithmetic: +, -, /, \*
- Logical: &&, ||
- Control flow: if/else, while
- Assignment operators
- print function

**Planned features for b0.1:**

- Function support
- Minimal vector operations
- Basic exception mechanism (stop keyword)

You could follow the development process [here](https://github.com/py39cptCiolacu/rr/milestone/1)

---

### 5. Sandbox

A preliminary RR version is in the **Sandbox** section of the website.

**Sandbox features:**

- Run provided examples or custom code
- Inspect bytecode execution of RR VM programs

> Useful for understanding high-level constructs, control flow, and debugging.

---

### 6. Want to help?

Join development or propose features:

- Email: **dciolacu87@yahoo.com**
- [GitHub repository](https://github.com/py39cptCiolacu/rr)
